<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Speedometer</title>
    <style>
        :root {
            --primary-color: #4299e1;
            --background-color: #f0f2f5;
            --card-background: white;
            --text-color: #2d3748;
            --secondary-text: #718096;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #63b3ed;
                --background-color: #1a202c;
                --card-background: #2d3748;
                --text-color: #f7fafc;
                --secondary-text: #cbd5e0;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            background: var(--card-background);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .speed-display {
            font-size: 4rem;
            font-weight: bold;
            margin: 1rem 0;
            transition: color 0.3s;
        }

        .speed-slow { color: #48bb78; }
        .speed-medium { color: #4299e1; }
        .speed-fast { color: #ed8936; }
        .speed-very-fast { color: #e53e3e; }

        .units {
            font-size: 1.5rem;
            color: var(--secondary-text);
            margin-bottom: 2rem;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
            text-align: left;
        }

        .stat-box {
            background: var(--background-color);
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        .button:hover {
            filter: brightness(1.1);
        }

        .button:disabled {
            background: var(--secondary-text);
            cursor: not-allowed;
        }

        .status {
            margin-top: 1rem;
            color: var(--secondary-text);
        }

        .error {
            color: #e53e3e;
            margin-top: 1rem;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--secondary-text);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GPS Speedometer</h1>

        <div class="speed-display">0</div>
        <div class="units">
            <span class="kph">0 km/h</span> | 
            <span class="mph">0 mph</span>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div>Max Speed:</div>
                <div class="max-speed">0 km/h</div>
            </div>
            <div class="stat-box">
                <div>Average Speed:</div>
                <div class="avg-speed">0 km/h</div>
            </div>
        </div>

        <button class="button" onclick="toggleTracking()">Start Tracking</button>
        <div class="status">Waiting to start...</div>
        <div class="error"></div>
    </div>

    <script>
        // State management
        const state = {
            isTracking: false,
            watchId: null,
            lastPosition: null,
            speeds: [],
            maxSpeed: 0,
            movingAverageWindow: [],
            lastPollTime: Date.now(),
            stationaryCount: 0
        };

        // Constants
        const ACCURACY_THRESHOLD = 20; // meters
        const MOVING_AVERAGE_SIZE = 5;
        const SPEED_THRESHOLDS = {
            SLOW: 20,
            MEDIUM: 40,
            FAST: 60,
            VERY_FAST: 80
        };

        // Kalman Filter parameters
        const kalmanFilter = {
            Q: 0.1, // process noise
            R: 0.1, // measurement noise
            x: null, // initial state
            P: 1 // initial estimate uncertainty
        };

        // DOM Elements
        const elements = {
            speedDisplay: document.querySelector('.speed-display'),
            kphDisplay: document.querySelector('.kph'),
            mphDisplay: document.querySelector('.mph'),
            maxSpeedDisplay: document.querySelector('.max-speed'),
            avgSpeedDisplay: document.querySelector('.avg-speed'),
            statusDisplay: document.querySelector('.status'),
            errorDisplay: document.querySelector('.error'),
            button: document.querySelector('.button')
        };

        // Kalman Filter update
        function updateKalmanFilter(measurement) {
            if (kalmanFilter.x === null) {
                kalmanFilter.x = measurement; // Initialize with the first measurement
            }
            // Prediction
            const P = kalmanFilter.P + kalmanFilter.Q;

            // Update
            const K = P / (P + kalmanFilter.R);
            kalmanFilter.x = kalmanFilter.x + K * (measurement - kalmanFilter.x);
            kalmanFilter.P = (1 - K) * P;

            return kalmanFilter.x;
        }

        // Moving average calculation
        function calculateMovingAverage(speed) {
            state.movingAverageWindow.push(speed);
            if (state.movingAverageWindow.length > MOVING_AVERAGE_SIZE) {
                state.movingAverageWindow.shift();
            }
            return state.movingAverageWindow.reduce((a, b) => a + b, 0) / state.movingAverageWindow.length;
        }

        // Update speed display
        function updateSpeedDisplay(speedKph) {
            elements.speedDisplay.textContent = Math.round(speedKph);
            elements.kphDisplay.textContent = `${speedKph.toFixed(1)} km/h`;
            elements.mphDisplay.textContent = `${(speedKph * 0.621371).toFixed(1)} mph`;

            elements.speedDisplay.className = 'speed-display';
            elements.speedDisplay.classList.remove('speed-slow', 'speed-medium', 'speed-fast', 'speed-very-fast');

            if (speedKph < SPEED_THRESHOLDS.SLOW) {
                elements.speedDisplay.classList.add('speed-slow');
            } else if (speedKph < SPEED_THRESHOLDS.MEDIUM) {
                elements.speedDisplay.classList.add('speed-medium');
            } else if (speedKph < SPEED_THRESHOLDS.FAST) {
                elements.speedDisplay.classList.add('speed-fast');
            } else {
                elements.speedDisplay.classList.add('speed-very-fast');
            }
        }

        // Update status message
        function updateStatus(message) {
            elements.statusDisplay.textContent = message;
        }

        // Handle GPS position updates
        function handlePositionUpdate(position) {
            const { latitude, longitude, speed, accuracy } = position.coords;
            if (accuracy > ACCURACY_THRESHOLD) {
                updateStatus('Low GPS accuracy, data skipped.');
                return;
            }

            const currentTime = Date.now();
            if (state.lastPosition) {
                const { latitude: lastLat, longitude: lastLon, timestamp: lastTime } = state.lastPosition;
                const distance = haversineDistance(lastLat, lastLon, latitude, longitude);
                const timeChange = (currentTime - lastTime) / 1000; // seconds

                if (timeChange > 0) {
                    const rawSpeedKph = (distance / timeChange) * 3.6; // m/s to km/h
                    const filteredSpeed = updateKalmanFilter(rawSpeedKph);
                    const avgSpeed = calculateMovingAverage(filteredSpeed);

                    state.speeds.push(filteredSpeed);
                    if (state.speeds.length > 100) state.speeds.shift();

                    if (filteredSpeed > state.maxSpeed) {
                        state.maxSpeed = filteredSpeed;
                        elements.maxSpeedDisplay.textContent = `${state.maxSpeed.toFixed(1)} km/h`;
                    }

                    elements.avgSpeedDisplay.textContent = `${avgSpeed.toFixed(1)} km/h`;
                    updateSpeedDisplay(filteredSpeed);

                    if (filteredSpeed < 5) {
                        state.stationaryCount++;
                    } else {
                        state.stationaryCount = 0;
                    }
                }
            }

            state.lastPosition = {
                latitude,
                longitude,
                timestamp: currentTime
            };
        }

        // Haversine formula for distance
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const toRadians = (deg) => (deg * Math.PI) / 180;
            const dLat = toRadians(lat2 - lat1);
            const dLon = toRadians(lon2 - lon1);

            const a = Math.sin(dLat / 2) ** 2 +
                      Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * Math.sin(dLon / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // Handle errors
        function handleError(error) {
            elements.errorDisplay.textContent = `Error: ${error.message}`;
        }

        // Start tracking
        function startTracking() {
            if (state.isTracking) return;

            state.isTracking = true;
            elements.button.textContent = 'Stop Tracking';
            updateStatus('Tracking started...');
            elements.errorDisplay.textContent = '';

            state.watchId = navigator.geolocation.watchPosition(handlePositionUpdate, handleError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000
            });

            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        // Stop tracking
        function stopTracking() {
            if (!state.isTracking) return;

            state.isTracking = false;
            elements.button.textContent = 'Start Tracking';
            updateStatus('Tracking stopped.');
            elements.errorDisplay.textContent = '';

            if (state.watchId !== null) {
                navigator.geolocation.clearWatch(state.watchId);
                state.watchId = null;
            }

            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }

        // Handle visibility changes
        function handleVisibilityChange() {
            if (document.visibilityState === 'visible' && state.isTracking) {
                updateStatus('Resumed tracking...');
            }
        }

        // Toggle tracking
        function toggleTracking() {
            if (state.isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        }
    </script>
</body>
</html>
        
        
